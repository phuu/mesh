<!DOCTYPE html>
<meta charset="utf-8">
<title></title>
<meta name="viewport" content="width=device-width">

<style>

  * {
    box-sizing: border-box;
  }

  body {
    font: 17px/1.5 'Avenir', sans-serif;
    color: #222;
    margin: 5em;
  }

  [data-mesh-active] {
    cursor: ns-resize;
  }

  [data-mesh-source] {
    color: blue;
    border-bottom: 1px dashed;
  }
  [data-mesh-source]:hover {
    cursor: ns-resize;
  }

  [data-mesh-target] {
    color: red;
  }

</style>

<h1>mesh</h1>

<p>Originally a 90 minute project with the theme "understand fast".</p>

<p>The idea is to be able to link data across a page quickly and easily, to give the user an understanding of how changing data affects outcomes.</p>

<p>Click and drag, up or down, on the numbers below to see how the result changes.</p>

<hr>

<p>
  I have
  <span data-mesh-source="apples" data-mesh-positive>12</span>
  apples to split between
  <span data-mesh-source="people" data-mesh-min="1" data-mesh-positive>3</span>
  people. Each gets
  <span data-mesh-target="@apples / @people" data-mesh-decimal="1">x</span> apples.
</p>

<p>
  The square of
  <span data-mesh-source="x" data-mesh-max="10" data-mesh-min="-10">5</span>
  is
  <span data-mesh-target="@x * @x">x * x</span>.
</p>

<p>
  According to Hick's Law, if the user's skill is
  <span data-mesh-source="skill" data-mesh-min="1" data-mesh-positive data-mesh-decimal>5</span>
  and there are
  <span data-mesh-source="items" data-mesh-positive>5</span>
  items on the page,
  the time taken to make a decision is
  <span data-mesh-target="@skill * (Math.log(@items + 1) / Math.log(2))" data-mesh-decimal></span>.
</p>

<script src="jquery.js"></script>
<script>
  $(function () {
    /* Config */
    var config = {
      dragSpeed: 1,
      updateDelay: 100,
      touch: ('ontouchstart' in window),
      save: ('localStorage' in window),
      prefix: 'data-mesh-'
    };

    var events = {
      start: (config.touch ? 'touchstart' : 'mousedown'),
      move: (config.touch ? 'touchmove' : 'mousemove'),
      end: (config.touch ? 'touchend' : 'mouseup'),
    };

    /* Recognised attribute types */
    var attr = {
      source: config.prefix + 'source',
      target: config.prefix + 'target',
      whole: config.prefix + 'whole',
      decimal: config.prefix + 'decimal',
      min: config.prefix + 'min',
      max: config.prefix + 'max',
      positive: config.prefix + 'positive',
      active: config.prefix + 'active'
    };

    /* Decimal place rounding */
    var roundToDp = function (value, decimalPlaces) {
      return Math.round(value * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces)
    };

    /* Grab the nodes we want */
    var $body    = $('body'),
        $sources = $('['+attr.source+']'),
        $targets = $('['+attr.target+']'),
        data     = {};

    /* Update all the target's values with the calculated value from the sources */
    var updateTargets = $targets.each.bind($targets, function () {
      var $this        = $(this),
          expr         = $this
                           .attr(attr.target)
                           /* Remove disallowed values */
                           .replace(/[^a-z0-9\/\+\-\*\(\)\.\@]/gi, ''),
          interpolated = expr,
          result = 0,
          decimalPlaces = 2;

      /* Grab all the source names and replace them for their values in the expression */
      Object.keys(data)
        .forEach(function (source) {
          interpolated = interpolated.replace(new RegExp('@' + source, 'ig'), data[source]);
        });

      try {

        /* Eval it (eek) against the page */
        result = parseFloat(eval(interpolated), 10);

        /* Round to decimal places if required */
        if( $this.is('['+attr.decimal+']') ) {
          decimalPlaces = parseInt($this.attr(attr.decimal), 10) || decimalPlaces;
          result = roundToDp(result, decimalPlaces);
        }

        /* Round it if required*/
        if( $this.is('['+attr.whole+']') ) result = Math.floor(result);

      } catch (e) {
        result = '0 (an error occurred)';
      }

      /* Send it on back */
      $this.text(result || 0);
    });

    /* Set a timer to update all targets */
    var prepareUpdate = (function () {
      var updateTimer;
      return function () {
        clearTimeout(updateTimer);
        updateTimer = setTimeout(updateTargets, config.updateDelay || 100);
      };
    }());

    /* Set a timer to save a particular source */
    var prepareSave = (function () {
      var saveTimer = {};
      return function (source, value) {
        if( !config.save ) return;
        clearTimeout(saveTimer[source]);
        saveTimer[source] = setTimeout(function () {
          localStorage.setItem(config.prefix + source, value);
        }, config.updateDelay || 100);
      };
    }());

    /* Restore a value from localStorage if it's enabled */
    var restore = function (source) {
      return (config.save ? localStorage.getItem(config.prefix + source) : false);
    };

    /* Extract important information for an event */
    var extractEvent = function (e) {
      var touch;
      /* If it's a touch event, copy the info over */
      if( config.touch && e.originalEvent.touches.length > 0 ) {
        touch = e.originalEvent.touches[0];
        Object.keys(touch)
          .forEach(function (key) {
            e[key] = touch[key];
          });
      }
      return e;
    };

    /* Initialise all the sources, including attaching event handlers */
    $sources.each(function () {
      var $this = $(this),
          source = $this.attr(attr.source),
          initialValue = parseFloat($this.text(), 10),
          minValue = parseFloat($this.attr(attr.min), 10) || -Infinity,
          maxValue = parseFloat($this.attr(attr.max), 10) || Infinity;

      /* Allow numbers to be clamped to positive values */
      if( $this.is('['+attr.positive+']') ) minValue = 0;

      /* Update the value of this source */
      var updateValue = function (value) {
        /* Clamp or limit the value */
        if( value !== 0 && !value ) value = 0;
        if( value < minValue ) value = minValue;
        if( value > maxValue ) value = maxValue;
        /* Update the display and storage */
        $this.text(value);
        data[source] = value;

        /* Update the targets and save */
        prepareUpdate();
        prepareSave(source, value);
      };

      /* Store information about current drag*/
      var drag = { active: false, start: {}, pos: {} };
      /* And an update function for the source's value */
      var update = function (e) {
        if( !drag.active ) return;

        /* Grab the important data */
        e = extractEvent(e);
        drag.pos.y = e.pageY;

        var raw_diff, diff;

        /* Calculate the value based on the drag distance */
        raw_diff = (drag.start.y - drag.pos.y) / (10 / (config.dragSpeed || 1));
        /* If this source is allowed to be decimal, don't floor it */
        diff = ($this.is('['+attr.decimal+']') ? roundToDp(raw_diff, 1) : Math.floor(raw_diff));

        /* Calculate the new value */
        val = roundToDp(drag.start.val + diff, 14);

        /* And perform an update */
        updateValue(val);
      };

      var end = function () {
        drag.active = false;
        $body
          .removeAttr(attr.active)
          .removeClass(attr.active);
      };

      /* Setup */

      /* If we're saving, and there's a value, grab it */
      updateValue(restore(source) || initialValue);

      /* Drag handlers. Yeah, this is alot. */
      $this
        .on(events.start, function (e) {
          if( drag.active ) return;
          e = extractEvent(e);
          e.preventDefault();
          drag.active = true;
          drag.start.y = e.pageY;
          drag.start.val = parseFloat($this.text(), 10);
          $body
            .attr(attr.active, true)
            .addClass(attr.active)
        })
        .on(events.move, update)
        .on(events.end, end);

      $this
        .parents()
        .on(events.move, update)
        .on(events.end, end);
    });

    prepareUpdate();
  });
</script>